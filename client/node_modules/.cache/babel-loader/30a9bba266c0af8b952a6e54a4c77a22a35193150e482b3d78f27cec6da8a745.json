{"ast":null,"code":"// Automated Review System\nconst REVIEW_INTERVALS = {\n  DAILY: 1,\n  WEEKLY: 7,\n  BIWEEKLY: 14,\n  MONTHLY: 30\n};\nexport class ReviewSystem {\n  constructor() {\n    this.reviewQueue = [];\n    this.reviewHistory = [];\n    this.spacedRepetition = new Map();\n  }\n  scheduleReview(question, performance) {\n    const reviewItem = {\n      question,\n      performance,\n      scheduledDate: this.calculateNextReview(performance),\n      attempts: 0,\n      lastReviewed: new Date()\n    };\n    this.reviewQueue.push(reviewItem);\n    this.spacedRepetition.set(question.id, reviewItem);\n  }\n  calculateNextReview(performance) {\n    const now = new Date();\n    let interval;\n    if (performance.score === 1) {\n      // If perfect score, review less frequently\n      interval = REVIEW_INTERVALS.MONTHLY;\n    } else if (performance.score >= 0.7) {\n      // If good score, review weekly\n      interval = REVIEW_INTERVALS.WEEKLY;\n    } else {\n      // If poor score, review daily\n      interval = REVIEW_INTERVALS.DAILY;\n    }\n    return new Date(now.getTime() + interval * 24 * 60 * 60 * 1000);\n  }\n  getDueReviews() {\n    const now = new Date();\n    return this.reviewQueue.filter(item => item.scheduledDate <= now);\n  }\n  updateReviewItem(questionId, newPerformance) {\n    const reviewItem = this.spacedRepetition.get(questionId);\n    if (reviewItem) {\n      reviewItem.performance = newPerformance;\n      reviewItem.scheduledDate = this.calculateNextReview(newPerformance);\n      reviewItem.attempts += 1;\n      reviewItem.lastReviewed = new Date();\n\n      // Update review history\n      this.reviewHistory.push({\n        questionId,\n        performance: newPerformance,\n        timestamp: new Date()\n      });\n    }\n  }\n  generateReviewSession() {\n    const dueReviews = this.getDueReviews();\n    if (dueReviews.length === 0) return null;\n\n    // Sort by priority (poorer performance first)\n    dueReviews.sort((a, b) => a.performance.score - b.performance.score);\n\n    // Create a review session with 5-10 questions\n    const sessionSize = Math.min(dueReviews.length, Math.floor(Math.random() * 6) + 5);\n    const sessionQuestions = dueReviews.slice(0, sessionSize);\n    return {\n      id: Date.now(),\n      questions: sessionQuestions.map(item => item.question),\n      scheduledDate: new Date(),\n      completed: false\n    };\n  }\n  getReviewStats() {\n    const stats = {\n      totalReviews: this.reviewHistory.length,\n      upcomingReviews: this.reviewQueue.length,\n      averagePerformance: 0,\n      improvementRate: 0\n    };\n    if (this.reviewHistory.length > 0) {\n      // Calculate average performance\n      stats.averagePerformance = this.reviewHistory.reduce((sum, item) => sum + item.performance.score, 0) / this.reviewHistory.length;\n\n      // Calculate improvement rate\n      const recentReviews = this.reviewHistory.slice(-10);\n      const olderReviews = this.reviewHistory.slice(-20, -10);\n      if (olderReviews.length > 0) {\n        const recentAvg = recentReviews.reduce((sum, item) => sum + item.performance.score, 0) / recentReviews.length;\n        const olderAvg = olderReviews.reduce((sum, item) => sum + item.performance.score, 0) / olderReviews.length;\n        stats.improvementRate = recentAvg - olderAvg;\n      }\n    }\n    return stats;\n  }\n  getReviewRecommendations() {\n    const recommendations = [];\n    const stats = this.getReviewStats();\n\n    // Check for upcoming reviews\n    if (stats.upcomingReviews > 0) {\n      recommendations.push({\n        type: 'review',\n        message: `You have ${stats.upcomingReviews} questions due for review`\n      });\n    }\n\n    // Check for performance trends\n    if (stats.improvementRate < 0) {\n      recommendations.push({\n        type: 'performance',\n        message: 'Consider reviewing more frequently to improve performance'\n      });\n    }\n\n    // Check for specific categories that need review\n    const categoryPerformance = this.analyzeCategoryPerformance();\n    Object.entries(categoryPerformance).forEach(([category, performance]) => {\n      if (performance < 0.7) {\n        recommendations.push({\n          type: 'category',\n          category,\n          message: `Focus on reviewing ${category.toLowerCase()} questions`\n        });\n      }\n    });\n    return recommendations;\n  }\n  analyzeCategoryPerformance() {\n    const categoryPerformance = {};\n    const recentReviews = this.reviewHistory.slice(-20);\n    recentReviews.forEach(review => {\n      const category = review.question.category;\n      if (!categoryPerformance[category]) {\n        categoryPerformance[category] = {\n          total: 0,\n          correct: 0\n        };\n      }\n      categoryPerformance[category].total += 1;\n      if (review.performance.score === 1) {\n        categoryPerformance[category].correct += 1;\n      }\n    });\n\n    // Calculate performance percentages\n    Object.entries(categoryPerformance).forEach(([category, data]) => {\n      categoryPerformance[category] = data.correct / data.total;\n    });\n    return categoryPerformance;\n  }\n  clearCompletedReviews() {\n    const now = new Date();\n    this.reviewQueue = this.reviewQueue.filter(item => {\n      const isCompleted = item.attempts >= 3 && item.performance.score === 1;\n      if (isCompleted) {\n        this.reviewHistory.push({\n          questionId: item.question.id,\n          performance: item.performance,\n          timestamp: now,\n          status: 'completed'\n        });\n      }\n      return !isCompleted;\n    });\n  }\n}","map":{"version":3,"names":["REVIEW_INTERVALS","DAILY","WEEKLY","BIWEEKLY","MONTHLY","ReviewSystem","constructor","reviewQueue","reviewHistory","spacedRepetition","Map","scheduleReview","question","performance","reviewItem","scheduledDate","calculateNextReview","attempts","lastReviewed","Date","push","set","id","now","interval","score","getTime","getDueReviews","filter","item","updateReviewItem","questionId","newPerformance","get","timestamp","generateReviewSession","dueReviews","length","sort","a","b","sessionSize","Math","min","floor","random","sessionQuestions","slice","questions","map","completed","getReviewStats","stats","totalReviews","upcomingReviews","averagePerformance","improvementRate","reduce","sum","recentReviews","olderReviews","recentAvg","olderAvg","getReviewRecommendations","recommendations","type","message","categoryPerformance","analyzeCategoryPerformance","Object","entries","forEach","category","toLowerCase","review","total","correct","data","clearCompletedReviews","isCompleted","status"],"sources":["C:/Users/asus/OneDrive/Desktop/autom/client/src/utils/automation/reviewSystem.js"],"sourcesContent":["// Automated Review System\r\nconst REVIEW_INTERVALS = {\r\n  DAILY: 1,\r\n  WEEKLY: 7,\r\n  BIWEEKLY: 14,\r\n  MONTHLY: 30\r\n};\r\n\r\nexport class ReviewSystem {\r\n  constructor() {\r\n    this.reviewQueue = [];\r\n    this.reviewHistory = [];\r\n    this.spacedRepetition = new Map();\r\n  }\r\n\r\n  scheduleReview(question, performance) {\r\n    const reviewItem = {\r\n      question,\r\n      performance,\r\n      scheduledDate: this.calculateNextReview(performance),\r\n      attempts: 0,\r\n      lastReviewed: new Date()\r\n    };\r\n\r\n    this.reviewQueue.push(reviewItem);\r\n    this.spacedRepetition.set(question.id, reviewItem);\r\n  }\r\n\r\n  calculateNextReview(performance) {\r\n    const now = new Date();\r\n    let interval;\r\n\r\n    if (performance.score === 1) {\r\n      // If perfect score, review less frequently\r\n      interval = REVIEW_INTERVALS.MONTHLY;\r\n    } else if (performance.score >= 0.7) {\r\n      // If good score, review weekly\r\n      interval = REVIEW_INTERVALS.WEEKLY;\r\n    } else {\r\n      // If poor score, review daily\r\n      interval = REVIEW_INTERVALS.DAILY;\r\n    }\r\n\r\n    return new Date(now.getTime() + interval * 24 * 60 * 60 * 1000);\r\n  }\r\n\r\n  getDueReviews() {\r\n    const now = new Date();\r\n    return this.reviewQueue.filter(item => item.scheduledDate <= now);\r\n  }\r\n\r\n  updateReviewItem(questionId, newPerformance) {\r\n    const reviewItem = this.spacedRepetition.get(questionId);\r\n    if (reviewItem) {\r\n      reviewItem.performance = newPerformance;\r\n      reviewItem.scheduledDate = this.calculateNextReview(newPerformance);\r\n      reviewItem.attempts += 1;\r\n      reviewItem.lastReviewed = new Date();\r\n\r\n      // Update review history\r\n      this.reviewHistory.push({\r\n        questionId,\r\n        performance: newPerformance,\r\n        timestamp: new Date()\r\n      });\r\n    }\r\n  }\r\n\r\n  generateReviewSession() {\r\n    const dueReviews = this.getDueReviews();\r\n    if (dueReviews.length === 0) return null;\r\n\r\n    // Sort by priority (poorer performance first)\r\n    dueReviews.sort((a, b) => a.performance.score - b.performance.score);\r\n\r\n    // Create a review session with 5-10 questions\r\n    const sessionSize = Math.min(dueReviews.length, Math.floor(Math.random() * 6) + 5);\r\n    const sessionQuestions = dueReviews.slice(0, sessionSize);\r\n\r\n    return {\r\n      id: Date.now(),\r\n      questions: sessionQuestions.map(item => item.question),\r\n      scheduledDate: new Date(),\r\n      completed: false\r\n    };\r\n  }\r\n\r\n  getReviewStats() {\r\n    const stats = {\r\n      totalReviews: this.reviewHistory.length,\r\n      upcomingReviews: this.reviewQueue.length,\r\n      averagePerformance: 0,\r\n      improvementRate: 0\r\n    };\r\n\r\n    if (this.reviewHistory.length > 0) {\r\n      // Calculate average performance\r\n      stats.averagePerformance = this.reviewHistory.reduce(\r\n        (sum, item) => sum + item.performance.score, 0\r\n      ) / this.reviewHistory.length;\r\n\r\n      // Calculate improvement rate\r\n      const recentReviews = this.reviewHistory.slice(-10);\r\n      const olderReviews = this.reviewHistory.slice(-20, -10);\r\n\r\n      if (olderReviews.length > 0) {\r\n        const recentAvg = recentReviews.reduce(\r\n          (sum, item) => sum + item.performance.score, 0\r\n        ) / recentReviews.length;\r\n\r\n        const olderAvg = olderReviews.reduce(\r\n          (sum, item) => sum + item.performance.score, 0\r\n        ) / olderReviews.length;\r\n\r\n        stats.improvementRate = recentAvg - olderAvg;\r\n      }\r\n    }\r\n\r\n    return stats;\r\n  }\r\n\r\n  getReviewRecommendations() {\r\n    const recommendations = [];\r\n    const stats = this.getReviewStats();\r\n\r\n    // Check for upcoming reviews\r\n    if (stats.upcomingReviews > 0) {\r\n      recommendations.push({\r\n        type: 'review',\r\n        message: `You have ${stats.upcomingReviews} questions due for review`\r\n      });\r\n    }\r\n\r\n    // Check for performance trends\r\n    if (stats.improvementRate < 0) {\r\n      recommendations.push({\r\n        type: 'performance',\r\n        message: 'Consider reviewing more frequently to improve performance'\r\n      });\r\n    }\r\n\r\n    // Check for specific categories that need review\r\n    const categoryPerformance = this.analyzeCategoryPerformance();\r\n    Object.entries(categoryPerformance).forEach(([category, performance]) => {\r\n      if (performance < 0.7) {\r\n        recommendations.push({\r\n          type: 'category',\r\n          category,\r\n          message: `Focus on reviewing ${category.toLowerCase()} questions`\r\n        });\r\n      }\r\n    });\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  analyzeCategoryPerformance() {\r\n    const categoryPerformance = {};\r\n    const recentReviews = this.reviewHistory.slice(-20);\r\n\r\n    recentReviews.forEach(review => {\r\n      const category = review.question.category;\r\n      if (!categoryPerformance[category]) {\r\n        categoryPerformance[category] = {\r\n          total: 0,\r\n          correct: 0\r\n        };\r\n      }\r\n\r\n      categoryPerformance[category].total += 1;\r\n      if (review.performance.score === 1) {\r\n        categoryPerformance[category].correct += 1;\r\n      }\r\n    });\r\n\r\n    // Calculate performance percentages\r\n    Object.entries(categoryPerformance).forEach(([category, data]) => {\r\n      categoryPerformance[category] = data.correct / data.total;\r\n    });\r\n\r\n    return categoryPerformance;\r\n  }\r\n\r\n  clearCompletedReviews() {\r\n    const now = new Date();\r\n    this.reviewQueue = this.reviewQueue.filter(item => {\r\n      const isCompleted = item.attempts >= 3 && item.performance.score === 1;\r\n      if (isCompleted) {\r\n        this.reviewHistory.push({\r\n          questionId: item.question.id,\r\n          performance: item.performance,\r\n          timestamp: now,\r\n          status: 'completed'\r\n        });\r\n      }\r\n      return !isCompleted;\r\n    });\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}