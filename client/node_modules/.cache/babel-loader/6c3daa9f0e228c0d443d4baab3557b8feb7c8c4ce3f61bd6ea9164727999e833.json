{"ast":null,"code":"// Assessment Flow Management\nconst DIFFICULTY_THRESHOLDS = {\n  EASY: 0.7,\n  // 70% correct to progress\n  MEDIUM: 0.8,\n  // 80% correct to progress\n  HARD: 0.9 // 90% correct to progress\n};\nconst MAX_ATTEMPTS = 3;\nexport class AssessmentFlow {\n  constructor() {\n    this.currentLevel = 1;\n    this.attempts = 0;\n    this.performanceHistory = [];\n    this.recommendedCategory = null;\n  }\n  updatePerformance(score, category, level) {\n    this.performanceHistory.push({\n      score,\n      category,\n      level,\n      timestamp: new Date()\n    });\n  }\n  shouldProgress(score, level) {\n    const threshold = level <= 2 ? DIFFICULTY_THRESHOLDS.EASY : level <= 4 ? DIFFICULTY_THRESHOLDS.MEDIUM : DIFFICULTY_THRESHOLDS.HARD;\n    return score >= threshold;\n  }\n  getNextLevel(score, currentLevel) {\n    if (this.shouldProgress(score, currentLevel)) {\n      return currentLevel + 1;\n    }\n    return currentLevel;\n  }\n  getRecommendedCategory() {\n    if (this.performanceHistory.length === 0) {\n      return 'NUMBER_RECOGNITION'; // Start with basics\n    }\n\n    // Calculate average scores for each category\n    const categoryScores = {};\n    this.performanceHistory.forEach(record => {\n      if (!categoryScores[record.category]) {\n        categoryScores[record.category] = {\n          total: 0,\n          count: 0\n        };\n      }\n      categoryScores[record.category].total += record.score;\n      categoryScores[record.category].count += 1;\n    });\n\n    // Find category with lowest average score\n    let lowestScore = Infinity;\n    let recommendedCategory = null;\n    Object.entries(categoryScores).forEach(([category, data]) => {\n      const average = data.total / data.count;\n      if (average < lowestScore) {\n        lowestScore = average;\n        recommendedCategory = category;\n      }\n    });\n    return recommendedCategory;\n  }\n  shouldReviewCategory(category) {\n    const categoryHistory = this.performanceHistory.filter(record => record.category === category);\n    if (categoryHistory.length === 0) return false;\n    const recentHistory = categoryHistory.slice(-3);\n    const averageScore = recentHistory.reduce((sum, record) => sum + record.score, 0) / recentHistory.length;\n    return averageScore < DIFFICULTY_THRESHOLDS.MEDIUM;\n  }\n  getReviewQuestions(category, level) {\n    const categoryHistory = this.performanceHistory.filter(record => record.category === category && record.level === level);\n    return categoryHistory.filter(record => record.score < DIFFICULTY_THRESHOLDS.MEDIUM).map(record => ({\n      category: record.category,\n      level: record.level,\n      timestamp: record.timestamp\n    }));\n  }\n  resetAttempts() {\n    this.attempts = 0;\n  }\n  incrementAttempts() {\n    this.attempts += 1;\n  }\n  shouldShowHint() {\n    return this.attempts >= MAX_ATTEMPTS;\n  }\n}","map":{"version":3,"names":["DIFFICULTY_THRESHOLDS","EASY","MEDIUM","HARD","MAX_ATTEMPTS","AssessmentFlow","constructor","currentLevel","attempts","performanceHistory","recommendedCategory","updatePerformance","score","category","level","push","timestamp","Date","shouldProgress","threshold","getNextLevel","getRecommendedCategory","length","categoryScores","forEach","record","total","count","lowestScore","Infinity","Object","entries","data","average","shouldReviewCategory","categoryHistory","filter","recentHistory","slice","averageScore","reduce","sum","getReviewQuestions","map","resetAttempts","incrementAttempts","shouldShowHint"],"sources":["C:/Users/asus/OneDrive/Desktop/autom/client/src/utils/automation/assessmentFlow.js"],"sourcesContent":["// Assessment Flow Management\r\nconst DIFFICULTY_THRESHOLDS = {\r\n  EASY: 0.7,    // 70% correct to progress\r\n  MEDIUM: 0.8,  // 80% correct to progress\r\n  HARD: 0.9     // 90% correct to progress\r\n};\r\n\r\nconst MAX_ATTEMPTS = 3;\r\n\r\nexport class AssessmentFlow {\r\n  constructor() {\r\n    this.currentLevel = 1;\r\n    this.attempts = 0;\r\n    this.performanceHistory = [];\r\n    this.recommendedCategory = null;\r\n  }\r\n\r\n  updatePerformance(score, category, level) {\r\n    this.performanceHistory.push({\r\n      score,\r\n      category,\r\n      level,\r\n      timestamp: new Date()\r\n    });\r\n  }\r\n\r\n  shouldProgress(score, level) {\r\n    const threshold = level <= 2 ? DIFFICULTY_THRESHOLDS.EASY :\r\n                     level <= 4 ? DIFFICULTY_THRESHOLDS.MEDIUM :\r\n                     DIFFICULTY_THRESHOLDS.HARD;\r\n    \r\n    return score >= threshold;\r\n  }\r\n\r\n  getNextLevel(score, currentLevel) {\r\n    if (this.shouldProgress(score, currentLevel)) {\r\n      return currentLevel + 1;\r\n    }\r\n    return currentLevel;\r\n  }\r\n\r\n  getRecommendedCategory() {\r\n    if (this.performanceHistory.length === 0) {\r\n      return 'NUMBER_RECOGNITION'; // Start with basics\r\n    }\r\n\r\n    // Calculate average scores for each category\r\n    const categoryScores = {};\r\n    this.performanceHistory.forEach(record => {\r\n      if (!categoryScores[record.category]) {\r\n        categoryScores[record.category] = {\r\n          total: 0,\r\n          count: 0\r\n        };\r\n      }\r\n      categoryScores[record.category].total += record.score;\r\n      categoryScores[record.category].count += 1;\r\n    });\r\n\r\n    // Find category with lowest average score\r\n    let lowestScore = Infinity;\r\n    let recommendedCategory = null;\r\n\r\n    Object.entries(categoryScores).forEach(([category, data]) => {\r\n      const average = data.total / data.count;\r\n      if (average < lowestScore) {\r\n        lowestScore = average;\r\n        recommendedCategory = category;\r\n      }\r\n    });\r\n\r\n    return recommendedCategory;\r\n  }\r\n\r\n  shouldReviewCategory(category) {\r\n    const categoryHistory = this.performanceHistory.filter(\r\n      record => record.category === category\r\n    );\r\n\r\n    if (categoryHistory.length === 0) return false;\r\n\r\n    const recentHistory = categoryHistory.slice(-3);\r\n    const averageScore = recentHistory.reduce(\r\n      (sum, record) => sum + record.score, 0\r\n    ) / recentHistory.length;\r\n\r\n    return averageScore < DIFFICULTY_THRESHOLDS.MEDIUM;\r\n  }\r\n\r\n  getReviewQuestions(category, level) {\r\n    const categoryHistory = this.performanceHistory.filter(\r\n      record => record.category === category && record.level === level\r\n    );\r\n\r\n    return categoryHistory\r\n      .filter(record => record.score < DIFFICULTY_THRESHOLDS.MEDIUM)\r\n      .map(record => ({\r\n        category: record.category,\r\n        level: record.level,\r\n        timestamp: record.timestamp\r\n      }));\r\n  }\r\n\r\n  resetAttempts() {\r\n    this.attempts = 0;\r\n  }\r\n\r\n  incrementAttempts() {\r\n    this.attempts += 1;\r\n  }\r\n\r\n  shouldShowHint() {\r\n    return this.attempts >= MAX_ATTEMPTS;\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}